package it.luca.disp.streaming.core.job

import it.luca.disp.core.BaseTestSuite
import it.luca.disp.streaming.core.ObjectDeserializer.deserializeAsMsgWrapper
import it.luca.disp.streaming.core.StringConsumerRecord
import it.luca.disp.streaming.core.dto.{RecordOperation, SuccessfulConversion}
import it.luca.disp.streaming.model.MsgWrapper
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.apache.kafka.common.record.TimestampType
import org.apache.spark.sql.{DataFrame, Row}
import org.apache.spark.storage.StorageLevel

import java.sql.Timestamp
import java.time.Instant
import java.time.format.DateTimeFormatter
import scala.io.Source

abstract class StreamingJobTest[T, S <: StreamingJob[T]](protected val streamingJob: S,
                                                         protected val dataClass: Class[T],
                                                         protected val sampleFile: String)
  extends BaseTestSuite {

  protected final val offset: Long = 300
  protected final val (topicName, topicPartition): (String, Int) = ("topicName", 1)
  protected final val recordTimestampLong: Long = System.currentTimeMillis()
  protected final val recordTimestampTs: Timestamp = Timestamp.from(Instant.ofEpochMilli(recordTimestampLong))
  protected final def createConsumerRecordWithValue(value: String): StringConsumerRecord = {

    new StringConsumerRecord(topicName,
      topicPartition,
      offset,
      recordTimestampLong,
      TimestampType.CREATE_TIME,
      0,
      0,
      0,
      null,
      value)
  }

  def run(): Unit = {

    val jsonString: String = Source
      .fromInputStream(getClass.getResourceAsStream(s"/samples/$sampleFile"))
      .getLines().mkString(" ")

    val testInstance: MsgWrapper[T] = deserializeAsMsgWrapper(jsonString, dataClass)
    val recordOperation: RecordOperation = streamingJob.processMessage(createConsumerRecordWithValue(jsonString))
    recordOperation shouldBe SuccessfulConversion(_ : ConsumerRecord[String, String], _ : DataFrame)

    val generatedDataFrame: DataFrame = recordOperation
      .asInstanceOf[SuccessfulConversion].dataFrame
      .persist(StorageLevel.MEMORY_ONLY)

    testConstantColumn(generatedDataFrame.select("record_offset"), _.getLong(0), offset)
    testConstantColumn(generatedDataFrame.select("record_topic"), _.getString(0), topicName)
    testConstantColumn(generatedDataFrame.select("record_partition"), _.getInt(0), topicPartition)

    testConstantColumn(generatedDataFrame.select("record_ts"), _.getTimestamp(0), recordTimestampTs)
    testConstantColumn(generatedDataFrame.select("record_dt"), _.getString(0), recordTimestampTs
      .toLocalDateTime
      .format(DateTimeFormatter.ISO_LOCAL_DATE))

    testGeneratedDataFrame(generatedDataFrame, testInstance.getPayload)
  }

  /**
   * Test that a column contains exactly one distinct value that should match expected value
   * @param dataFrame [[DataFrame]] to be tested
   * @param rowValueExtraction function for extracting a value from a [[Row]]
   * @param expectedValue value to be matched
   * @tparam U type of expected value
   */

  protected final def testConstantColumn[U](dataFrame: DataFrame, rowValueExtraction: Row => U, expectedValue: U): Unit = {

    val rows: Array[Row] = dataFrame.distinct.collect()
    rows.length shouldBe 1
    rowValueExtraction(rows.head) shouldBe expectedValue
  }

  /**
   * Test that a column contains expected values
   * @param dataFrame [[DataFrame]] to be tested
   * @param rowValueExtraction function for extracting a value from a [[Row]]
   * @param expectedValues collection of values to be matched by dataframe rows
   * @tparam U type of expected value
   */

  protected final def testNonConstantColumn[U](dataFrame: DataFrame, rowValueExtraction: Row => U, expectedValues: Seq[U]): Unit = {

    val actualValues: Seq[U] = dataFrame.collect.map(rowValueExtraction)
    actualValues.zipWithIndex.foreach { case (actualValue, index) =>
      actualValue shouldBe expectedValues(index)
    }
  }

  /**
   * Test dataFrame generated by [[StreamingJob]] under test
   * @param dataFrame [[DataFrame]] to test
   * @param instance instance to test the dataFrame against
   */

  protected def testGeneratedDataFrame(dataFrame: DataFrame, instance: T): Unit
}
